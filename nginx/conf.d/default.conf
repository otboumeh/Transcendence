server {
    listen 80;
    server_name _;
    # Root directory for static files
    root /var/www/html/public;
    index index.php index.html;
    # Handle PHP files
    location ~ \.php$ {
        try_files $uri /index.php =404;
        fastcgi_pass backend:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME /var/www/html/public/$fastcgi_script_name;
        include fastcgi_params;
    }
    # Handle static files
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }
}

# server {
    # listen 80;
    # server_name localhost;

    # # Regla para reenviar las peticiones a la API al backend (PHP-FPM)
    # # Cualquier URL que empiece por /api/ irá al servicio 'backend'.
    # location /api/ {
        # # Esta línea es importante para que el script PHP reciba la ruta correcta.
        # # Elimina el prefijo /api de la URL antes de pasarla.
        # rewrite ^/api/(.*)$ /$1 break;
        
        # include fastcgi_params;
        # # La variable $document_root aquí se refiere a la raíz que se necesita para el script.
        # # Asumiendo que tu punto de entrada de la API está en /var/www/html/public/api/
        # fastcgi_param SCRIPT_FILENAME /var/www/html/public/$fastcgi_script_name;
        # fastcgi_pass backend:9000;
    # }

    # # Regla para reenviar todo el resto del tráfico al frontend
    # # Esta es la regla por defecto si la URL no empieza por /api/.
    # location / {
        # # 'frontend' es el nombre del servicio en docker-compose.
        # proxy_pass http://frontend:3000;

        # # Cabeceras necesarias para que el proxy funcione correctamente con WebSockets y peticiones modernas.
		# # Se utilizan para reenviar información crucial del cliente original al servidor backend, datos que de otro modo se perderían cuando NGINX actúa como intermediario (proxy)
        
		# # Estas dos directivas trabajan juntas y son esenciales para permitir la comunicación a través de protocolos como WebSockets, que se usan en chats y juegos en tiempo real.
		# # Un cliente inicia una conexión WebSocket pidiendo "actualizar" (upgrade) la conexión HTTP estándar a una conexión persistente. Estas cabeceras transmiten esa solicitud de actualización a través de NGINX hasta el servidor backend.
		# proxy_set_header Upgrade $http_upgrade;
        # proxy_set_header Connection "upgrade";

		# # Sin esta cabecera -> El backend solo vería el nombre interno del proxy (ej. frontend:3000) en lugar del dominio real que el usuario escribió (ej. mi-aplicacion.com).
		# # Esta cabecera conserva el nombre de dominio original solicitado por el usuario.
        # proxy_set_header Host $host;

		# # Para el servidor backend, todas las peticiones parecen venir de la dirección IP de NGINX.
		# # Crea una cabecera X-Real-IP que contiene la dirección IP real del usuario.
        # proxy_set_header X-Real-IP $remote_addr;

		# # Esta cabecera mantiene una lista de todas las direcciones IP por las que ha pasado una petición
        # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

		# # Es común que un usuario se conecte a NGINX por HTTPS (seguro), pero que NGINX se comunique con el backend por HTTP (interno, no cifrado). El backend pensaría erróneamente que la conexión es insegura.
		# # Esta cabecera le dice al backend qué protocolo (http o https) usó el cliente original. Esto permite al backend, por ejemplo, forzar redirecciones a HTTPS o generar enlaces https:// correctamente.
        # proxy_set_header X-Forwarded-Proto $scheme;
    # }
# }